import * as sys from "./sys";
export { ImageFormat, Kernel3x3, ResizeArgs, ThumbnailArgs } from "./sys";
export declare class Image {
    private handle;
    constructor(x: sys.Image);
    static open(path: string): Promise<Image>;
    static open_with_format(path: string, format: sys.ImageFormat): Promise<Image>;
    static create(width: Number, height: Number, pixel_type: "rgba" | "rgb" | "luma"): Promise<Image>;
    dimensions(): Promise<sys.Resolution>;
    crop(cx: Number, cy: Number, width: Number, height: Number): Promise<Image>;
    color(): Promise<sys.ColorInfo>;
    grayscale(): Promise<Image>;
    invert(): Promise<Image>;
    resize(args: sys.ResizeArgs): Promise<Image>;
    thumbnail(args: sys.ThumbnailArgs): Promise<Image>;
    blur(sigma: Number): Promise<Image>;
    unsharpen(sigma: Number, threshold: Number): Promise<Image>;
    filter3x3(kernel: sys.Kernel3x3): Promise<Image>;
    adjust_contrast(contrast: Number): Promise<Image>;
    brighten(value: Number): Promise<Image>;
    huerotate(value: Number): Promise<Image>;
    flipv(): Promise<Image>;
    fliph(): Promise<Image>;
    rotate90(): Promise<Image>;
    rotate180(): Promise<Image>;
    rotate270(): Promise<Image>;
    save(path: String): Promise<null>;
    save_with_format(path: String, format: sys.ImageFormat): Promise<null>;
    map_rgba(f: (x: number, y: number, px: Array<number>) => Array<number>): Promise<Image>;
    reduce_rgba<T>(initial_value: T, f: (accumulator: T, x: number, y: number, px: Array<number>) => T): Promise<T>;
    map_luma(f: (x: number, y: number, px: number) => number): Promise<Image>;
    reduce_luma<T>(initial_value: T, f: (accumulator: T, x: number, y: number, px: number) => T): Promise<T>;
    adaptive_threshold(block_radius: Number): Promise<Image>;
    equalize_histogram(): Promise<Image>;
    match_histogram(target: Image): Promise<Image>;
    otsu_level(): Promise<Image>;
    stretch_contrast(lower: Number, upper: Number): Promise<Image>;
    threshold(thresh: Number): Promise<Image>;
    distance_transform(norm: "L1" | "LInf"): Promise<Image>;
    canny(low_threshold: Number, high_threshold: Number): Promise<Image>;
    box_filter(x_radius: Number, y_radius: Number): Promise<Image>;
    gaussian_blur_f32(sigma: Number): Promise<Image>;
    horizontal_filter(kernel: Array<Number>): Promise<Image>;
    median_filter(x_radius: Number, y_radius: Number): Promise<Image>;
    separable_filter(h_kernel: Array<Number>, v_kernel: Array<Number>): Promise<Image>;
    separable_filter_equal(kernel: Array<Number>): Promise<Image>;
    sharpen3x3(): Promise<Image>;
    sharpen_gaussian(sigma: Number, amount: Number): Promise<Image>;
    vertical_filter(kernel: Array<Number>): Promise<Image>;
    morph_close(norm: "L1" | "LInf", k: Number): Promise<Image>;
    morph_dilate(norm: "L1" | "LInf", k: Number): Promise<Image>;
    morph_erode(norm: "L1" | "LInf", k: Number): Promise<Image>;
    morph_open(norm: "L1" | "LInf", k: Number): Promise<Image>;
    gaussian_noise(mean: Number, stddev: Number, seed: Number): Promise<Image>;
    salt_and_pepper_noise(rate: Number, seed: Number): Promise<Image>;
    connected_components(conn: "Four" | "Eight", background: Number): Promise<GrayImageU32>;
    shrink_width(target_width: Number): Promise<Image>;
}
export declare class GrayImageU32 {
    private handle;
    constructor(x: sys.GrayImageU32);
    map_luma(f: (x: number, y: number, px: number) => number): Promise<GrayImageU32>;
    reduce_luma<T>(initial_value: T, f: (accumulator: T, x: number, y: number, px: number) => T): Promise<T>;
    to_image(): Promise<Image>;
}
